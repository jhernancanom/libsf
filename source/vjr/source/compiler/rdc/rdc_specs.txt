//////////
//
// /libsf/source/vjr/source/compiler/rdc/rdc_specs.txt
//
//////
//    _     _ _     _____ _____ 
//   | |   (_) |__ / ____|  ___|
//   | |   | | '_ \\___ \|  __|
//   | |___| | |_) |___) | |
//   |_____|_|_.__/_____/|_|
//
//   Liberty Software Foundation
// and the Village Freedom Project
//   __     _______     ____  
//   \ \   / /  ___| __|  _ \ 
//    \ \ / /| |_ | '__| |_) |
//     \ V / |  _|| |  |  __/ 
//      \_/  |_|  |_|  |_|
//
//////
// Version 0.57
// Copyright (c) 2014 by Rick C. Hodgin
//////
// Last update:
//     Nov.02.2014
//////
// Change log:
//     Jan.09.2015 - Added function purposes
//     Nov.02.2014 - Initial creation
//////
//
// This document is released as Liberty Software under a Repeat License, as governed
// by the Public Benefit License v1.0 or later (PBL).
//
// The PBL is a public domain license with a caveat:  self accountability unto God.
// You are free to use, copy, modify and share this software for any purpose, however,
// it is the desire of those working on this project that the software remain open.
// It is our request that you maintain it that way.  This is not a legal request unto
// our court systems, but rather a personal matter between you and God.  Our talents
// were received from God, and given to you through this forum.  And it is our wish
// that those talents reach out to as many as possible in a form allowing them to wield
// this content for their own betterment, as you are now considering doing.  And whereas
// we could've forced the issue through something like a copyleft-protected release, the
// truth is we are all giving an account of our lives unto God continually by the daily
// choices we make.  And here again is another case where you get to demonstrate your
// character unto God, and unto your fellow man.
//
// Jesus came to this Earth to set the captives free, to save men's eternal souls from
// the punishment demanded by our sin.  Each one of us is given the opportunity to
// receive Him in this world and be saved.  Whether we choose to receive Him, and follow
// Him, and purpose our lives on the goals He has for each of us (all of which are
// beneficial for all involved), is one way we reveal our character continually.  God
// sees straight through to the heart, bypassing all of the words, all of the facades.
// He is our Creator, and He knows who we are truly.
//
// Jesus is called "Christ" because He saves men from the eternal flames of Hell, the
// just punishment of rebellion against God (rebellion against truth) by eternal beings,
// which each of us are.
//
// Do not let His free gift escape you because of some desire to shortcut what is right
// in your life. Instead, do what is right, and do it because He is who He is, and what
// He has done to save us from such a fate.  Demonstrate to Him, to me, and to all of
// mankind, and to all of the Heavenly hosts, exactly who you are on the inside.  Receive
// Jesus Christ into your heart, learn of Him, of how He came here to guide us into that
// which is of His Kingdom and will be forever hereafter we leave this world.  Do this,
// and live.
//
// Every project released by Liberty Software Foundation will include a copy of the
// pbl.txt document, which can be found at http://www.libsf.org/licenses/.
//
// For additional information about this project, or to view the license, see:
//
//     http://www.libsf.org/
//     http://www.libsf.org/licenses/
//     http://www.visual-freepro.org/vjr/indexmain.html
//     http://www.visual-freepro.org/wiki/index.php/PBL
//
// Thank you.  And may The Lord bless you richly as you lift up your life, your
// talents, your gifts, your praise, unto Him.  In Jesus' name I pray.  Amen.
//
//////
//    _____   _____    _____ 
//   |  __ \ |  __ \  / ____|
//   | |__) || |  | || |     
//   |  _  / | |  | || |     
//   | | \ \ | |__| || |____ 
//   |_|  \_\|_____/  \_____|
//  Rapid Development Compiler
//
//////////




Nov.03.2014 -- Early draft.  Incomplete.  Inconsistent.
Mar.09.2015 -- Approaching finalization.  Still in draft form.




RDC Specifications Document
---------------------------

1.0 - Reserved Keywords
-----------------------

	(|cask|)		-- Reference cask
	[|cask|]		-- Definition cask
	<|cask|>		-- Logic cask
	~|cask|~		-- Utility cask

	void			-- An unspecified type
	bool			-- 8-bit boolean quantity which explicitly tests 0 for false, all others true
	char			-- 8-bit signed quantity
	short			-- 16-bit signed quantity
	int				-- 32-bit signed quantity
	long			-- 64-bit signed quantity
	real4,float		-- 32-bit floating point
	real8,double	-- 64-bit floating point
	real10			-- 80-bit floating point
	var				-- A weakly typed variable defined by usage
	alias			-- Alias a token to a longer form for ease of typing (alias rc = hwndx->window->properties->geometry.rc;)

	s8,u8			-- Signed and unsigned 8-bit quantities
	s16,u16			-- Signed and unsigned 16-bit quantities
	s32,u32			-- Signed and unsigned 32-bit quantities
	s64,u64			-- Signed and unsigned 64-bit quantities
	f32,f64,f80		-- 32-bit, 64-bit, and 80-bit floating point (if hardware doesn't support, wraps to bfp)
	
	as8,au8			-- Auto-converting signed and unsigned 32-bit quantities, load and stored as 8-bit quantities with signed/unsigned saturation
	as16,au16		-- Auto-converting signed and unsigned 32-bit quantities, load and stored as 16-bit quantities with signed/unsigned saturation
	as24,au24		-- Auto-converting signed and unsigned 32-bit quantities, load and stored as 24-bit quantities with signed/unsigned saturation
	
	xs8,xu8			-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 8-bit quantities with signed/unsigned saturation
	xs16,xu16		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 16-bit quantities with signed/unsigned saturation
	xs24,xu24		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 24-bit quantities with signed/unsigned saturation
	xs32,xu32		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 32-bit quantities with signed/unsigned saturation
	xs40,xu40		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 40-bit quantities with signed/unsigned saturation
	xs48,xu48		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 48-bit quantities with signed/unsigned saturation
	xs56,xu56		-- Extended auto-converting signed and unsigned 64-bit quantities, load and stored as 56-bit quantities with signed/unsigned saturation
	
	bi				-- Arbitrary precision big integer, defaults to 128 bits
	bfp				-- Arbitrary precision floating point, defaults to 256 bits
	datum			-- An explicitly allocated piece of data with a pointer and length
	date			-- A date with year, month, day
	datetime		-- A datetime with year, month, day, hour, minute, second, millisecond
	thread			-- A thread variable
	process			-- A process variable

	const,ro		-- Augments a type to indicate it is read-only
	rw				-- Augments a type to explicitly indicate it is read-write
	volatile		-- Augments a type to indicate it is to be coded as conveyed
	successive		-- Variables put into the successive block are always expressed exactly that way in memory (no reordering)
	literal			-- Specifies the data form is to be used literally, and remain unchanged changed even during optimization
	hide			-- Augments a type to indicate it should not be visible in SourceLight (typically used for unused / reserved members)
	unsigned		-- Augments char, short, int, long to make it unsigned
	static			-- Augments a definition to make it a singleton
	extern			-- Augments a type to indicate its body is populated elsewhere
	sizeof			-- Returns the size of a type
	countof			-- Returns the count of a type
	offsetof		-- Returns the offset of a type

	NULL			-- A constant pointer to 0x0
	null			-- A constant integer value of 0 or 0.0 (depending on context)
	true			-- Sets a bool to 0xff
	yes				-- Sets a bool to 0xff
	false			-- Sets a bool to 0x00
	no				-- Sets a bool to 0x00

	and				-- A verbose form of &&
	or				-- A verbose form of ||
	not				-- A verbose form of !
	xor				-- A verbose form of ^
	shiftl			-- A verbose form of <<
	shiftr			-- A verbose form of >>

	#define			-- Pragma definition of a token or macro
	#undefine		-- Pragma un-definition of a token
	#if				-- Pragma logic test for conditionally compiled code
	#ifdef			-- Pragma logic test for the existence of a token
	#ifndef			-- Pragma logic test for the non-existence of a token
	#else			-- Pragma logic test for conditionally compiled code
	#elseif			-- Pragma logic test for conditionally compiled code
	#endif			-- Pragma termination of a conditional test block
	#align			-- An alignment directive
	#push			-- Pushes a token value onto the stack
	#pop			-- Pops a token value from the stack
	#out			-- Displays text at compile time
	#warning		-- Displays a warning at the indicated location
	#error			-- Displays an error at the indicated location
	typedef			-- Typedefs one type to another name

	struct			-- A structure definition
	class			-- A class definition
	operator		-- For operator override definitions
	extends			-- A class extends another class (can extend multiple simultaneously)
	inherits		-- A pseudonym of extends
	parent			-- A reference to the immediate parent in an inheritance chain
	super			-- A pseudonym for parent
	child			-- A reference to the immediate child in an inheritance chain
	union			-- A merging of two or more types
	enum			-- An enumeration of items
	new				-- Creates an instance of a class
	newscope		-- Creates an instance of a class, automatically deleting it when it leaves current scope
	delete			-- Deletes an instance of a class
	deleteall		-- Deletes all instances of all classes defined in current scope

	adhoc			-- Declares an adhoc
	function		-- Declares a function
	port			-- Declares an initial launch port within a function
	purpose			-- Declares a purpose within a function
	params			-- Declares input parameters
	returns			-- Declares output return values
	inline			-- Provides an explicit optimization hint
	optimize		-- Provides an optimization hint level (0=none, 9=max)
	nodebug			-- Declares that a function should not be entered on single-step debugging
	nodbg			-- A pseudonym for nodebug
	breakpoint		-- Code will trap to the debugger if connected and engaged, ignored otherwise
	debug			-- A pseudonym for breakpoint
	accessor		-- Document and indicate the member function is an accessor, thereby removing the () syntax access requirement (use class->func->xyz rather than class->func()->xyz).

	do				-- Loop which always enters once, requires trailing while test
	while			-- Conditionally tests loop logic and continues in the loop if true
	until			-- Conditionally tests loop logic and continues in the loop if false
	iterate			-- Repeat a task a specified number of times
	for				-- A for loop
	unless			-- A conditional test on false
	roll			-- Executes as many of the conditionals as possible (until one evaluates to false)
	if				-- A conditional test on true
	else			-- An else clause on an if or unless
	elseif			-- An elseif clause on an
	lif				-- A line conditional test on true which executes multiple items on source-code line without braces, separated by semicolons
	lelse			-- A line conditional test on false which executes multiple items on source-code line without braces, separated by semicolons
	lelseif			-- A line elseif clause on an if or unless, which executes multiple items on source-code line without braces, separated by semicolons
	fif				-- A full test of all conditionals
	felse			-- An else statement in the fif..felseif..felse form, identical to else
	felseif			-- An elseif with full test of all conditionals
	switch			-- A switch statement
	case			-- A member test of a switch statement
	meta,mefa		-- Called on logic test result (meta called on true, mefa called on false)
	quit			-- Quits the application explicitly (calls OS's endProcess() function)

	in				-- Creates a new thread
	andin			-- Creates an additional new thread (used at the same time as in { })
	out				-- Leave a thread
	join			-- Joins the current thread to one (or more) thread(s) before continuing
	timeout			-- Callback for each join-attempted thread that did not out before timeout (typically an adhoc or utility cask)
	success			-- Callback if threads joined successfully before the timeout (typically an adhoc or utility cask)

	engage			-- Launches another process
	unengage		-- Explicitly ends a running process launched with engage

	marker			-- Create a marker, allowing for explicit for multi-level returns to this location by marker name
	enter			-- Code to execute upon natural entry into the chain
	leave			-- Code to execute upon natural exit from the chain
	flow			-- Code to execute when flow control returns to the home marker explicitly.

	default			-- In a port or switch statement, specifies the unspecified operation
	otherwise		-- A pseudonym for default
	break			-- Breaks the current loop
	breakto			-- Breaks to the indicated goto level
	continue		-- Continues to the current level
	continueto		-- Continues to the indicated goto level
	exit			-- A pseudonym for break
	exitto			-- A pseudonym for breakto
	loop			-- A pseudonym for continue
	loopto			-- A pseudonym for continueto
	goto			-- Goes to the indicated label or named block
	return			-- Returns from a called function and optionally explicitly returns
					   one or more of the following:  a value, values, a meia, mema, or
					   home.

	flow			-- A structured flow control block
	flowout			-- Exit a structured flow control block 
	flowoutto		-- Exit a structured flow control block to an indicated goto level
	flowto			-- Flow to a member of a structured flow control block
	subflow			-- Defines a subflow member of a strutured flow control block
	meia			-- Called on an inquiry
	mema			-- Called on a message (an extra and optional return message from a called thing)

	flowof			-- Defines a function to be a flow of another function
	assuper			-- Executes commands from the parent's point of view (as in "assuper return;")
	asmarker		-- Executes commands from the marker's point of view (as in "asmarker x = 5;" updates the 'x' in scope as at the marker)


1.1 - New Operators
-----------------------

	Reverse operators are addd for source code convenience, as well as ad hoc
	code execution in a command window.  Rather than reversing the typewritten
	quantity, the > < surround operators allow it to be reversed programmatically.
	
		>-<		-- Reversing minus, such as b - a; is computed as a >-< b;
		>+<		-- Reversing plus, such as b + a; is computed as a >+< b;
		>*<		-- Reversing multiply, such as b * a; is computed as a >*< b;
		>/<		-- Reversing divide, such as b / a; is computed as a >/< b;
		
		Note:  Some of these have significance in floating point numbers.

1.2 - Simplified Pointers
-------------------------

	RDC does not distinguish between . and ->. They are completely interchangeable.  In
	addition, repeated . or - (hyphen) character can be used for visual clarity, such as
	this..that being the same as this.that, being the same as this---->that, being the
	same as this->that, etc.

2.0 - Program Engagement
------------------------

	RDC defines engage and unengage as the start and ending concepts for running a program.
	In order to run, startup code is called to engage the application.  When flow brings the
	program to a close, it is goes through unengaging steps until it is fully unengaged.

	main() is the top level user-function for creating a console-based application.
	main() is defined as int main(int argc, char* argv[]);.

	dllmain() is the top level user-function for creating a DLL.
	dllmain() is defined as bool dllmain(u32 instance, u32 callType);

	guimain() is the top level user-function for creating a gui-based application.
	guimain() is defined in various forms depending on the operating system in use, and is
	analgous to WinMain() on Windows.

	For backward compatibility other definitions of dllmain() may also exist.

	At startup, an application compiled with RDC will go through these stages:
		(1) Engaging steps of self-initialization, global/static memory to default values.
		(2) Link to all required DLLs.
		(3) Call dllmain() in sequence for each loaded DLL.
		(3) Call main(), dllmain(), or guimain() for user app.

	Upon closing, an application compiled with RDC will go through these stages:
		(1) Unengaging steps of releasing OS handles and allocated memory blocks.
		(2) Saving any machine-state information (depending on what platform the
			RDC-compiled code was running on).
		(3) Signal its unengage() to the OS, which ends the program.


2.1 - Function and Adhoc Definitions
------------------------------------

	RDC provides for functions, adhocs, and flowof functions (which are a special type of
	function designed to abstract logic from a parent function).  In addition, RDC allows
	for multiple return parameters.
	
	The general C/C++ syntax form is allowable.  RDC adds an additional syntax form
	allowance:
	
		function nameOfFunction
		| returns int x, int y, int z;
		| params int a, int b, int c;
		{
			// Code goes here
			
			// Instead of issuing return(1,2,3), you can use:
			x = 1;
			y = 2;
			z = 3;
			
			// An implicit return here will not result in an error
		}
	
	Adhocs are special functions which can be declared near to some location which needs
	to have its logic extracted.  They reference the local variable environment of where
	they are defined, and also prvide for their own discreet additions.  As with flow {...}
	blocks, issuing assuper return; will exit out of the parent function, and not out of
	itself.  The general C/C++ syntax form is allowable here as well.  RDC adds an
	additional syntax form allowance:
	
		function nameOfFunction
		| returns int x;
		| params int a, int b, int c;
		{
			// Some code can go here
		
			// Normal flow does not enter an adhoc
			adhoc myAdhoc
			| returns int x;	// x here hides nameofFunction's x return parameter
			| params int a;		// a here hides nameOfFunction's a parameter
			{
				int b, c;		// b here hides nameOfFunction's b parameter
								// c remains accessible
				
				b = (super.b + a + super.a) * c;
				x = b * b;
			}
			
			// An implicit return here will not result in an error
			x = myAdhoc(a + b + c);
		}

2.2 - Flow Control
------------------

	RDC provides standard flow control mechanisms:
	
		do {
				// Code always enters this loop at least once
			} while (condition};	// Repeats while true
			
		do {
				// Code here
			} until (condition);	// Repeats while false
			
		while (condition) {
				// Code only enters the loop if condition is initially true
			}
			
		until (condition) {
				// Code only enters the loop if condition is initially false
			}
			
		int n = 10;
		iterate (n) {
				// Repeats the indicated number of times
			}
			
		for (init; condition; incrementer) {
				// Repeats until condition is false
			}
			
		// If and unless can operate together
		if (condition) {
				// Flows here if condition is true
			} else if (condition2) {
				// Flows here if condition2 is true
			} elseif (condition3) {
				// Flows here if condition3 is true
			} else unless (condition4) {
				// Flows here if  condition4 is false
			} else {
				// If condition and condition2 were false, flows here
			}
			
		unless (condition) {
				// Flows here if condition is false
			} else unless (condition2) {
				// Flows here if condition2 is false
			} else if (condition3) {
				// Flows here if condition3 is true
			} elseif (condition4) {
				// Flows here if condition4 is true
			} else  {
				// Flows here otherwise
			}
			
			// A line-if, does not require braces, executes each item on line
				lif (condition)			command1; command2; command3;
			lelseif (condition2)		command4; command5;
			lelse						command6; command7; command8;
			
		switch (variable) {
				case constant_test:
					break;
				case constant_test2:
					break;
				case constant..range:
					break;
				default:
					// If nothing above matched, flows here
					break;
			}
		
		// A switch with multiple constant tests
		switch (variable1, variable2[, ...]) {
				case constant_test1_1, constant_test1_2:
					break;
				case constant_test2_1, constant_test2_2:
					break;
				case constant1..range, constant2_test3:
					break;
				case constant_test3, constant2..range:
					break;
				case constant1..range, constant2..range:
					break;
				default:
					// If nothing above matched, flows here
					break;
			}
			
		// A switch form based on logic tests
		switch {
				case condition:		// Perform a non-constant test
					break;
				case condition2:	// Perform a logic test
					break;
				default:
					break;
			}

2.3 - Markers
-------------

	RDC provides for markers, which are sign posts or indicators noting specific places
	in the normal flow of an application that have been passed in the descent.  These
	mark places in code that can be returned to through a type of multi-level return.
	
	Consider the descent sequence main() to level1() to level2() to level3():
	
		function main
		| returns int exitCode;
		| params int argc, char* argv[];
		{
			level1();
		}
		
		function level1
		{
			level2();
		}
		
		function level2
		{
			level3();
		}
		
		function level3
		{
			// Eventually flow lands here
		}
	
	Suppose you wanted to return directly to main() from level3().  How would you
	do this?  In RDC, the marker cask has been introduced to allow for this ability.
	Markers are introduced wherever flow should be allowed.
	
	Consider:
	
		function main
		| returns int exitCode;
		| params int argc, char* argv[];
		{
			level1() [|marker|top||];
		}
		
		function level1
		{
			level2();
		}
		
		function level2
		{
			level3();
		}
		
		function level3
		{
			// To return directly to main(), do this:
			flowto marker top;
		}

	The marker can either be anonymous, or it can have an explicit name.  Multiple
	markers can be defined, and they are entered into, and exited out of, like a
	normal stack.  However, sequential markers on the stack can be directly bypassed
	using the flowto marker	keyword, which will look for an explicit marker by name,
	potentially skipping all others to get there.
	
	Markers are physically defined by casks, and can be inserted into normal program
	flow wherever they are desired.  In the example above, the [|marker|top||] cask
	is inserted after the level1() function call, meaning flow control would return
	immediately after that point in the program.
	
	However, consider something like this:
	
		function main
		| returns int exitCode;
		| params int argc, char* argv[];
		{
			[|marker|reset||] level1();
		}
	
	In this case a marker called "reset" has been created, which would flow to the
	point in the program before level1() was called, allowing for some descent code
	which may have encountered a condition where it failed to reset itself and start
	over without implementing complex logic through variable tests.

	Markers can make use of a normal [|definition cask|] to simply define a marker
	that can be referenced by name, allowing flow control to return to that location
	with the "flowto marker" command.
	
	In addition, a marker ~|utility cask|~ can be defined to allow for event processing,
	giving the ability to directly execute arbitrary code upon the normal signaling of
	events as entry, exit, and flowto the marker.  And if the ~|utility cask|~ signals
	an adhoc or function, the events are available as ports (see "14.0 - Function Ports").

3.0 - Assignment Operations
---------------------------

	All values descending in size are sign-saturated to the lesser size.
	All values ascending in size are sign-extended to the greater size.
	All global variables are initialized to their explicit value, or 0s, before main() is called.
	All signed and unsigned values becoming a float or double will convert as closely as possible.
	All float or double values becoming a signed or unsigned value will round.
	All assignments will be done with = or :=.

3.1 - builder Type
------------------

	An explicit builder type is provided, which allows for concatenating operations
	as for an output string, or structure array that may grow during runtime.  It is
	allocated in default-size blocks, which are typically 16 KB, but can be of nearly
	any size.  Several built-in functions are defined to allow builder types to be
	used easily for many tasks.

		struct SBuilder
		{
			uptr*		buffer;
			uptr		populatedLength;
			uptr		allocatedLength;
		};

3.2 - datum Type
----------------

	An explicit datum type is provided, which allows for sequential data to be stored,
	along with its length.  datums are essentially pointers to the following structure:
	
		struct SDatum
		{
			uptr*		buffer;
			uptr		length;
		};
	
3.3 - Weak var Type
-------------------

	Weak var types are essentially built-in pointers to the following structure:
	
		struct SVariable
		{
			u32			type;
			SDatum		value;
		};
	
	References to the various types can be made through explicit conversion creating a
	new var type, or usage if they are already in the required form.  Several built-in
	functions are defined to allow var types to be used easily for many tasks.
	
	The value member in var types have built-in references for all fundamental types,
	using the direct form, as in "data_s8" shown here:
	
		var fred = "Hi, mom.";
		sprintf(fred->value.data_s8);
	
	These types are provided:
	
	Values:
		_s8, _u8, _s16, _u16, _s32, _u32, _s64, _u64, _f32, _f64, _bi, _bfp
		
	Pointers to values:
		_s8p, _u8p, _s16p, _u16p, _s32p, _u32p, _s64p, _u64p, _f32p, _f64p, _bip, _bfpp
		
	Pointer to pointers to values:
		_s8pp, _u8pp, _s16pp, _u16pp, _s32pp, _u32pp, _s64pp, _u64pp, _f32pp, _f64pp, _bipp, _bfppp

4.0 - Comparison Operations
---------------------------

	All signed compares of equal size will be compared as signed values.
	All unsigned compares of equal size will be compared as unsigned values.

	All signed/unsigned compares will be compared thusly:
		(1) Signed is bigger, unsigned is upsized to signed's size, and compared.
		(2) Unsigned is bigger, unsigned and signed are both upsized to unsigned's
		    larger, and compared.

	All float and signed or unsigned compares will be converted to float and compared.
	All double and signed or unsigned compares will be converted to double and compared.
	All non-bool values used for logic tests will be explicitly compared to 0 for false.

	Comparison operators:
		(1) ==, tests for equal
		(2) >=, tests for greater than or equal to
		(3) <=, tests for less than or equal to
		(4) >, tests for greater than
		(5) <, tests for less than
		(6) !=, tests for not equal
		(7) !>=, tests for not greater than or equal to
		(8) !<=, tests for not less than or equal to
		(9) !>, tests for not greater than
		(10) !<, tests for not less than
		(11) $, found in (comparing one datum to another)
		(12) !$, not found in (comparing one datum to another)

5.0 - Thread Operations
-----------------------

	RDC will use OS services to create threads using the in {...} andin {...} syntax.
	Example:

		s64 lnMilliseconds;
		s32 sum1, sum2, sum3;
		thread t1, t2, t3;


		//////////
		// Launch three threads running sumPiDigits()
		//////
			in t1 {
				sum1 = sumPiDigits();

			} andin t2 {
				sum2 = sumPiDigits();

			} andin t3 {
				sum3 = sumPiDigits();

			} meia(thread* t) {
				// Called on inquiry if t1, t2, or t3 are already engaged
			}
			printf("Threads launched:\nT1: %u\nT2: %u\nT3: %u\n", t1.id, t2.id, t3.id);


		//////////
		// Create two adhoc functions for our join results
		//////
			adhoc myTimeout
			| params thread* t, void* data;
			{
				allThreadsCompleted = true;
				printf("Thread %u timed out!\n", t->id);
			}

			adhoc allGood
			| params void;
			{
				printf("All threads completed okay.\n")
			}


		//////////
		// Join with those threads before continuing
		//////
			lnMilliseconds = join(t1, t2, t3)::success(allGood)::timeout(10, myTimeout, NULL);


	Each thread will execute the code within, which can call other functions, etc.
	Thread unengage will automatically signal when its closing brace is reached.
	To explicitly exit a thread at any point, use the [out] keyword.

6.0 - Unions and Anonymous Unions
---------------------------------

	Unions and anonymous unions can be declared at any point a variable is declared in RDC.
	This includes function parameter declarations.  The keyword union is not required.

		function printEncoding
		| returns u32 r1;
		| params union {u32 iValue, f32 fValue}, bool* equal;
		{
			printf("The value %f in hex %x\n", fValue, iValue);
			*equal = ((int)fValue == iValue);
			return(iValue);
		}

		// The above would be the same as without the union keyword:

		function printEncoding
		| returns u32 r1;
		| params {u32 iValue, f32 fValue}, bool* equal;
		{
			printf("The value %f in hex %x\n", fValue, iValue);
			*equal = ((int)fValue == iValue);
			r1 = iValue;
		}

7.0 - Multiple Return Parameters
--------------------------------

	Functions can return multiple parameters.  As with input parameters being
	comma-delimited, so are return parameters.

		int r1, r2;

		r1, r2 = myFunction(int a, int b);

		function myFunction
		| returns int r1, int r2;
		| params int a, int b;
		{
			// Code for the function goes here
		}

8.0 - Flow Blocks
-----------------

	Flow blocks allow program logic to be removed from its deeply nested location, and
	moved to a documented location, allowing the mechanics of the underlying logic to be
	hidden from the overall big-picture view of the algorithm.  This is useful in
	maintenance and debugging.

	Flow blocks also allow for structured programming to exist in logic cases where
	spaghetti code would otherwise only be possible without complexity in navigating
	through the various levels.

		flow name
		| int ret1;
		{
			// Code for the normal operation goes here
			flowto sampleCallAndExit;
			ret1 = sampleCallAndReturnValue(1,2);

			// To explicitly flow out of the flow block at any time:
			flowout;


		} always before {
			// Code to execute always before the flow


		} always after {
			// Code to execute always after the flow


		} subflow sampleCallAndReturnValue
			| returns int r;
			| params int a, int b;
			{
				// Code for the subflow goes here
				// Control will automatically return when it reaches the closing brace
				// To explicitly return:
				return;

				// To explicitly return completely out of the flow block:
				assuper return;

				// To explicitly flow out of the flow block:
				flowout;


		} subflow sampleCallAndExit {
			// Code for the subflow goes here
			// Control will automatically exit when it reaches the closing brace


		} meia name {
			// Code for meia goes here (inquiry, a type of exception)


		} mema name {
			// Code for mema goes here
		}

9.0 - Flowof Functions
----------------------

	Flowof functions are functions which take code from another function and move it
	into a new location, but one which completely inherits the parameter, local, and
	variable environment of its parent.

	Like flow blocks, flowof functions are designed to remove complex logic from an
	otherwise nested flow, and place it in a manageable location leaving only a useful
	name "stub" at its previous location, yet without changing the environment of its
	symbols and defined parameters and variables.

		function xyz
		| returns int r1, int r2;
		| params int x, int y;
		{
			int a, b;

			abc();
			def();

			printf("a=%d, b=%d\n", a, b);
			// Implicit return, but abc() have already set r1, r2
		}

		function abc flowof xyz
		{
			// Declare our own local variables
			int a, j;	// a's definition here hides a above

			// Able to access the variables from xyz
			a       = 5 * x;  // Local assignment
			super.a = a;      // Parent's a is still accessible as super.a

            j       = a * 4;
			b       = 9 * y;
			r1      = 3 * j;
			r2      = 14 * j;
		}

		function def flowof xyz
		{
			int t;		// Declare our own local variables

			t = a;		// Store a to t temporarily
			a = b;		// Set a to b from above
			b = t;		// Set b to t
		}

10.0 - Casks
------------

	Casks allow injection of code at locations which are otherwise syntactically correct.
	Casks can also define things, and act conditionally based upon logic tests.  In their
	text-based form they are somewhat difficult to wield.  When presented within an RDC
	graphical editor, however they become a graphical construct conveying additional
	meaning and isolation unto to the eye.

		(|reference|)			-- Refers to something which already exists
		[|definition|]			-- Defines a new thing
		<|logic|>				-- Acts based on a logic test
		~|utility|~				-- Injects arbitary code

	Casks can also have return and input parameters.

		(||return|cask|)		-- An example of where return parameters go
		(|cask|input||)			-- An example of where input parameters go
		(||return|cask|input||)	-- An example with both return and input parameters

	Definition and utility casks define their thing in cask form:

		[||int r1, int r2|function xyz|int a, int b||]
		{
			// Code goes here
		}

	Syntax equivalent to:
	
		function xzy
		| returns int r1, int r2;
		| params int a, int b;
		{
			// Code goes here
		}

	Logic test casks perform tests for logic flow and engagement:
		<||test|if true|if false||>		&& Equivalent to ((test) ? if true : if false);

	Utility casks allow arbitary code injection:
		~|name|code goes here||~

	Executing multiple bits of code:
		~|name|code goes here; more code; more code;||~

	Executing intermixed code and called functions:
		~|name|code here; someFunction(); more code; etc...||~
	
	
	-----
	There is a special type of utility cask which is used with the name "marker".
	It uses the full cask syntax, including the marker name on the left parameter,
	the keyword "marker" for the cask's name, and the code to execute on the right
	parameter.
	
	Example:
		~||name|marker|code here; someFunction(); more code; etc...||~
	
	Typically these will more often be used with an adhoc function that has been setup
	to process marker ports.
	
	Definition of the adhoc or function exists at some point in scope:
	
		adhoc reset
		// Optional parameters can be received, but return parameters are out of scope
		// as there is no ability to reference them in a marker cask.  When required,
		// local or global variables can be used within an adhoc, and global variables
		// within a function, along with any passed parameter pointers being updated
		// to any location.
		{
			port in
			{
			}
			
			port out
			{
			}
			
			port flowto
			{
			}
		}
	
	Reerence is then made in the program by insertion of the ~|utility cask|~ marker:
	
		function something
		{
			~||name|marker|reset()||~ normal_command();
		}
	
	In this case, the marker is inserted before the normal_command(), which means it
	can act as a reset should anything normal_command() calls result in a failure
	which is not recoverable.
	
	Because utility casks can also directly define code to execute, including ports,
	the ability to add code directly without the use of an adhoc or function is also
	provided.
	
	Example:

		function something
		{
			~||reset|marker|||~
			{
				port in
				{
				}
				
				port out
				{
				}
				
				port flowto
				{
				}
				
			} normal_command();
		}

	This is functionally equivalent to the example above with the adhoc reset and the
	"function something" reference.  Note that the entire definition of the
	~|utility cask|~ was conducted through the ~| and |~ markers, with the { and }
	content as well, before the "normal_command();" was executed.  The ~|utility cask|~
	here named "reset" could also be later referenced by another utility cask.
	
	Example:

		function something
		{
			~||reset|marker|||~
			{
				port in
				{
				}
				
				port out
				{
				}
				
				port flowto
				{
				}
				
			} normal_command();
			
			~||reset2|marker|reset()||~ normal_command2();
		}
	
	These abilities allow for many different ways to accomplish the same task.  Some
	may be more or less desirable based on syntax preferences, and documentation needs.

11.0 - The Class
----------------

	RDC defines the class with multiple-inheritance, constructors, destructors,
	operator overrides, and member overloading.  All members are public, and the
	keywords new and delete are used to create a class instance, and delete the
	same.
	
		class name extends class1, class2, class3, ... classN
		{
		}

	Parent or inherited class member functions which are overridden by child members
	can be referenced from within member class functions using the syntax:

		class1->member();		// Accesses explicitly named member function
		super->member();		// Accesses immediate parent member function

	The order in the above example will be name, class1, class2, class3, ... classN.

12.0 - Function Overloading and Name Attributifying
---------------------------------------------------

	RDC allows for function overloading and wil not use mangled names, but instead will
	attach attributes of the function form to the name as a postfix adjustment to the
	normal function or adhoc name.

	The format will be the types in order from left-most return to right-most parameter,
	with pointers appending the suffix p and pointer-to-pointers appending the suffix pp:

		function name
		| returns int r1, float r2
		| params char p1, int* p2, double** p3
		{
			// Code goes here
		}

	The attributified name would be name__int_float_char_intp_doublepp().  If custom
	structs or classes are referenced, they are included by name as well.  If a typedef
	is in effect, the typdef name is included as is.

		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Code goes here
		}

	The attributified name would be name__cabsp_smystructp_sbgra().  In this way,
	external applications can link directly to the function knowing exactly the input
	types, and there is never any ambiguity as to the expected input parameters.

13.0 - LiveCode ABI
-------------------

	RDC employs a new ABI that's designed around two central concepts:
	
		(1)  Every compilation is for a target machine architecture, not an OS flavor.
		(2)  Every compilation is targeted for LiveCode support.
	
	The code generated operates on a particular instruction set.  To provide OS
	facilities, a thin OS-specific wrapper is required to launch the ABI.  This
	will allow direct hookup to any required facilities, provide translation between
	RDC requirements and those services natively available on the OS.  However, a
	single generated output file can be run on any machine that is for the targeted
	architecture, and has a wrapper to support it.

14.0 - Function Ports
---------------------

	RDC allows for known-at-compile-time parameter branching into specific
	destinations within the function block so that runtime testing is not
	required.  It is used like a switch statement, and must appear as the
	top-most non-declaratory item in the function's source code.  By default,
	when a port is used, any item that is not known at compile time will
	automatically be directed to the default: code.
	
		function name
		| returns CAbc* abc
		| params int type, datum* data
		{
			port (type)
			{
				case _CHARACTER:
					// Automatically entered if type = _CHARACTER
					break;
					
				case _INTEGER:
					// Automatically entered if type = _INTEGER
					break;
				
				default:
					// Automatically entered if type is not _CHARACTER or _INTEGER
					break;
			}
		}
	
	To assist in automatically processing unknown parameters without the need of
	additional source code, RDC will also allow the "port switch" syntax, which will
	act as both a port and a switch based on whether the value is known or unknown
	at compile time.  In such a case, the port code will automatically be entered
	into if the parameter value is known at compile time, and it will automatically
	enter the switch logic if it is not known at compile time.
	
		function name
		| returns CAbc* abc
		| params int type, datum* data
		{
			port switch (type)
			{
				case _CHARACTER:
					// Automatically entered if type = _CHARACTER
					break;
					
				case _INTEGER:
					// Automatically entered if type = _INTEGER
					break;
				
				default:
					// Automatically entered if type is not _CHARACTER or _INTEGER
					break;
			}
		}
	
	To test more than one parameter for port entry, use commas:
	
		function name
		| returns CAbc* abc
		| params int type, int subtype, datum* data
		{
			port switch (type, subtype)
			{
				case _CHARACTER, _SIGNED:
					// Automatically entered if type = _CHARACTER and subtype = _SIGNED
					break;
					
				case _CHARACTER, _UNSIGNED:
					// Automatically entered if type = _CHARACTER and subtype = _SIGNED
					break;
					
				case _INTEGER, _S32:
					// Automatically entered if type = _INTEGER and subtype = _S32
					break;
					
				case _INTEGER, _S64:
					// Automatically entered if type = _INTEGER and subtype = _S64
					break;
				
				default:
					// Automatically entered if any of the four combinations above
					// are not satisfied.
					break;
			}
		}
	
	The port functionality will allow speedups on various multi-purpose functions
	which receive constants as passed parameters, and must examine those parameters
	to determine what to do within.

14.1 - Pre-defined ports
------------------------

	RDC allows for some pre-defined ports which are arbitrary code markers, and
	are automatically signaled through normal execution, or explicitly by name.
	
	These include:  in, out, always, always before, always after
	
	The always, always before, and always after allow for an optional "once" keyword,
	which will signal their execution only once per thread.
	
	Consider:
	
		adhoc name
		{
			//////////
			// Can be used anywhere:
			//////
				port always [once] {
				}
				
				port always before [once] {
				}
				
				port always after [once] {
				}


			//////////
			// Used only in markers:
			//////
				port in
				{
					// Code to execute on the normal entry into a marker
				}
				
				port out
				{
					// Code to execute on the normal exit out of a marker
				}
				
				port flowto
				{
					// Code to execute on the "flowto marker" command goes here
					// Note:  When a flowto marker is signaled, it will not automatically
					//        signal the out port, but only this one.  However, the out
					//        code can be explicitly called using the "name().out" syntax.
				}
		}

15.0 - Function Purposes
------------------------

	RDC employs groupings within a single function which allow for self-documenting
	code and multi-targeted operations all under the same "function umbrella."
	This exists outside of the general class structure and is designed to further
	align source code with its true purpose per context.  Each one is called a
	"purpose".
	
	Functions can have multiple entry points based on their purposes.  Each purpose
	is a self-contained entity that acts as a separate function being referenced in
	source code using "name().help();" syntax, as in the example below.  The normal
	function content is accessed using "name();" or "name().main();".
	
		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Explicitly named purpose accessed in source code as "name().help();"
			purpose help {
				// Code for this purpose goes here
			}
			
			// Normal code is the default purpose when not named, or the "main" purpose.
		}
	
	Each purpose can override function parameter blocks using its own parameter block.
	
		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Explicitly named purpose with its own parameter block
			purpose help
			| returns s8* helpText
			| params void
			{
				// Code for this purpose goes here
			}
			
			// Normal code is the default purpose when not named, or the "main" purpose.
		}
	
	To access this function, you would use "labc = name(lms, color);" for the main purpose,
	and for the help purpose it could be accessed as "printf("%s\n", name().help());".
	
	Each purpose can also have its own destination ports within, and these are honored
	when the parameter is known as advance (as per enums and constants).
	
	The purpose of the "purpose" ability in functions is to allow a single function to more
	fully encapsulate the various qualities that would typically be required for related
	functionality within a class as separate and discrete entities within its implementation
	in a system.  Purposes can be created for different variable types, for example, or to
	include self-documenting code, test suites, and more.  And if the function itself must
	not contain a main() body, but instead must explicitly require named purposes throughout,
	it can use the "purpose" keyword in its parameter block to indicate that it is a purpose-
	only function.
	
	For example:

		function convert
		| purpose	// Only purposes are allowed below
		{
			//////////
			// Explicitly named int-to-char purpose
			//////
				purpose toChar
				| returns s8* output
				| params int input
				{
					// Code to convert the integer input to a string here
				}
			
			
			//////////
			// Explicitly named char-to-int purpose
			//////
				purpose toInt
				| returns int output
				| params s8* input
				{
					// Code to convert the string to integer goes here
				}

			// Normal code is not allowed here because it was declared above "| purpose"
			// in the "function convert" parameter block.
		}
	
	To use these functions it would be:
	
		lcNumber = convert().toChar(20);
		lnValue  = convert().toInt("123");
	
	Were these to be added to a class or struct as member functions, then it
	would have the following syntax:
	
		CSample sample = new CSample();

		lcNumber = sample.convert().toChar(20);
		lnValue  = sample.convert().toInt("123");
		
		
--------------
New:

Nov.24.2014
Prefix/postfix combination operators for modulo, and, or, xor.
The same for ++ and --:

		++%i.4;    //        i = ((i + 1) % 4); use i
		i++%.4;    // t = i; i = ((i + 1) % 4); use t

		++&i.4;    //        i = ((i + 1) & 4); use i
		i++&.4;    // t = i; i = ((i + 1) & 4); use t

		++|i.4;    //        i = ((i + 1) | 4); use i
		i++|.4;    // t = i; i = ((i + 1) | 4); use t

		++^i.4;    //        i = ((i + 1) ^ 4); use i
		i++^.4;    // t = i; i = ((i + 1) ^ 4); use t


Dec.27.2014
The address of literals will be made available.

	int sample(int* value)
	{
		return(*value + 3);
	}
	
	int main(int argc, char* argv[])
	{
	    int i = 5;
		printf("%d\n", sample(&i));
		printf("%d\n", sample(&5));
		return 0;
	}


Dec.27.2014
A new instruction called roll() executes as many as possible though the conditionals
in a type of logic test, but there need not be a block for entry based on the results
of the logic test.  Instead, roll() can simply execute and continue on.

In order to enter the block, roll() must be explicitly followed by braces, and there
is no single-line form as with if().

roll() was created to allow rolling processing through each logical item until one
fails, and then it will, based on its form, either stop processing, assign NULLs,
or assign a count, or all three.

roll() is used when a variable number of components exist, and each one in succession
is dependent upon the prior result, which causes it to roll through the calculation.

roll() exists with three components (like a for()):

	roll(assignment; conditional; count);

These forms take on specific meaning when present. The assignment is an auto-
assignment given for all values which exist in the x=y form after the first failure
is encountered. The conditional is the actual conditional logic, which can be
anything in a normal if() statement. And the count will be used to indicated how
many were processed through the conditionals (including non-assignments) before
the first failure was encountered.

roll() provides a stand-alone syntax in which no semicolons are present. If any
semicolons are used, all three must be present.

-----
Example operation using INVALID_PTR assignment, and storing a count:

	lnCount	= 0;
    c1		= f(cRoot);
	if (c1)
	{
		++lnCount;
	    c2 = f(c1);
		if (c2)
		{
			++lnCount;
			c3 = f(c2);
			if (c3)
			{
				++lnCount;
				some_operation();
			
			} else {
				c3 = INVALID_PTR;
			}
		
		} else {
			c2 = INVALID_PTR;
			c3 = INVALID_PTR;
		}
	
	} else {
		c1 = INVALID_PTR;
		c2 = INVALID_PTR;
		c3 = INVALID_PTR;
	}

-----
Using roll():

	roll (INVALID_PTR; (c1 = f(cRoot)) && (c2 = f(c1)) && (c3 = f(c2)); lnCount)
	{
		// Only entered if the logic all passed
		some_operation();
	}

-----
Using roll() as a stand-alone without some_operation() being required:

	roll (INVALID_PTR; (c1 = f(cRoot)) && (c2 = f(c1)) && (c3 = f(c2)); lnCount);
